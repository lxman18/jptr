<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jupiter Allocation</title>
  <link href="https://fonts.googleapis.com/css?family=Material+Icons|Material+Icons+Outlined" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background-color: #f4f4f4;
      overflow-x: hidden;
    }
    header {
      background-color: #4CAF50;
      color: white;
      padding: 1rem;
      text-align: center;
      position: relative;
      z-index: 10;
    }
    main {
      padding: 1rem;
      position: relative;
      min-height: 100vh;
      z-index: 5;
    }
    .upload-section {
      background: white;
      padding: 2rem;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      text-align: center;
      position: relative;
      z-index: 10;
      max-width: 500px;
      margin: 0 auto;
    }
    .file-input {
      display: none;
    }
    .upload-label {
      display: inline-block;
      padding: 0.5rem 1rem;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      border-radius: 4px;
      transition: transform 0.3s ease, background-color 0.3s ease;
    }
    .upload-label:hover {
      transform: scale(1.1);
      background-color: #45a049;
    }
    .output-log {
      margin-top: 1rem;
      white-space: pre-wrap;
      background: #eee;
      padding: 1rem;
      border-radius: 4px;
      font-size: 0.9rem;
      position: relative;
      z-index: 10;
    }
    .progress-container {
      width: 100%;
      background: #ddd;
      border-radius: 20px;
      margin-top: 1rem;
      height: 20px;
      overflow: hidden;
      display: none;
    }
    .progress-bar {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #4CAF50, #45a049);
      text-align: center;
      line-height: 20px;
      color: white;
      font-size: 0.8rem;
      transition: width 0.2s ease;
    }
    .scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #151515;
      z-index: 2;
      display: none;
    }
    .scene.active {
      display: flex;
    }
    .rocket {
      position: relative;
      animation: animate 0.2s ease infinite;
    }
    .rocket::after {
      content: "";
      position: absolute;
      bottom: -200px;
      left: 50%;
      transform: translateX(-50%);
      width: 10px;
      height: 200px;
      background: linear-gradient(#00d0ff, transparent);
    }
    .scene i {
      position: absolute;
      top: -200px;
      background-color: rgba(255, 255, 255, 0.5);
      animation: animateStars linear infinite;
    }
    @keyframes animate {
      0% { transform: translateY(2px); }
      100% { transform: translateY(-2px); }
    }
    @keyframes animateStars {
      0% { transform: translateY(0); }
      100% { transform: translateY(200vh); }
    }
    .success-animation {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 3rem;
      color: #4CAF50;
      text-align: center;
      animation: popIn 0.5s ease-out, fadeOut 2s 1s forwards;
      z-index: 1000;
      display: none;
    }
    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @keyframes fadeOut {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jupiter Allocation</h1>
  </header>
  <main>
    <div class="scene" id="processingScene">
      <div class="rocket">
        <img src="https://i.postimg.cc/QtdPrSsD/rocket.png" alt="Rocket">
      </div>
    </div>
    <section class="upload-section">
      <input type="file" id="inputFile" class="file-input" accept=".xlsx, .xls" />
      <label for="inputFile" class="upload-label">
        <span class="material-icons-outlined">upload_file</span> Upload Excel File
      </label>
      <div id="log" class="output-log"></div>
      <div class="progress-container">
        <div id="progressBar" class="progress-bar">0%</div>
      </div>
    </section>
    <div id="successAnimation" class="success-animation">✅ Success!</div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
  function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${year}${month}${day}_${hours}${minutes}${seconds}`;
  }

  function parseDateFromCell(value) {
    if (!value) return null;
    
    // Handle Excel serial number dates
    if (typeof value === 'number') {
      const dateParts = XLSX.SSF.parse_date_code(value);
      if (dateParts) {
        return new Date(dateParts.y, dateParts.m - 1, dateParts.d);
      }
    }
    
    // Handle string dates with multiple formats
    if (typeof value === 'string') {
      const formats = [
        'YYYY-MM-DD',
        'MM/DD/YYYY',
        'DD-MM-YYYY',
        'YYYY/MM/DD',
        'DD/MM/YYYY',
        'M/D/YYYY',
        'D/M/YYYY',
        'YYYY-MM-DD HH:mm:ss',
        'MM/DD/YYYY HH:mm:ss'
      ];
      for (let format of formats) {
        const parsed = new Date(value.replace(/(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})/, '$3-$1-$2'));
        if (!isNaN(parsed.getTime())) {
          parsed.setHours(0, 0, 0, 0);
          return parsed;
        }
      }
      
      // Try direct parsing as a fallback
      const directParsed = new Date(value);
      if (!isNaN(directParsed.getTime())) {
        directParsed.setHours(0, 0, 0, 0);
        return directParsed;
      }
    }
    
    // Handle Date objects (if cellDates: true)
    if (value instanceof Date && !isNaN(value.getTime())) {
      value.setHours(0, 0, 0, 0);
      return value;
    }
    
    return null;
  }

  function getWorkingDays(start, end) {
    let startCal = new Date(start);
    let endCal = new Date(end);
    
    // Normalize dates to remove time component
    startCal.setHours(0, 0, 0, 0);
    endCal.setHours(0, 0, 0, 0);
    
    let workDays = 0;
    while (startCal <= endCal) {
      const day = startCal.getDay();
      if (day !== 0 && day !== 6) workDays++;
      startCal.setDate(startCal.getDate() + 1);
    }
    return Math.max(workDays - 1, 0);
  }

  function getAgingLabel(days) {
    if (days <= 1) return "0 - 1 day";
    if (days <= 3) return "2 - 3 days";
    if (days <= 5) return "4 - 5 days";
    return "Above 5 days";
  }

  function normalizeDate(date) {
    const cal = new Date(date);
    cal.setHours(0, 0, 0, 0);
    return cal;
  }

  function stars() {
    let scene = document.querySelector(".scene");
    let count = 20;
    for (let i = 0; i < count; i++) {
      let star = document.createElement("i");
      let x = Math.floor(Math.random() * window.innerWidth);
      let duration = Math.random() * 1 + 0.5;
      let h = Math.random() * 100;
      star.style.left = x + "px";
      star.style.width = "1px";
      star.style.height = h + "px";
      star.style.animationDuration = duration + "s";
      scene.appendChild(star);
    }
  }

  async function processExcel(file) {
    const logDiv = document.getElementById('log');
    const successAnimation = document.getElementById('successAnimation');
    const processingScene = document.getElementById('processingScene');
    const progressContainer = document.querySelector('.progress-container');
    const progressBar = document.getElementById('progressBar');

    if (file.size > 20 * 1024 * 1024) {
      logDiv.textContent = '❌ File size exceeds 20 MB limit. Please use a smaller file.\n';
      return;
    }

    logDiv.textContent = 'Processing file...\n';
    processingScene.classList.add('active');
    stars();
    progressContainer.style.display = "block";
    progressBar.style.width = "0%";
    progressBar.textContent = "0%";

    const desiredHeaders = [
      "Country", "AP Ref #", "Input Source", "Current State", "Work Type",
      "Exception Reason", "Document Type", "Currency", "Invoice No", "Supplier Name",
      "Supplier Number", "PO Number", "Invoice: Created Date", "Current Owner",
      "Previous State", "Comment History", "Company Code", "Current State Assign Date",
      "Invoice Due Date", "Created date aging", "Created date aging AH",
      "Current State assigned date", "Current state assigned date aging AH",
      "Overdue/Neardue", "Inflow Type", "Total Amount", "Converted Invoice Total Amount",
      "AMT in MN", "Ownership", "Status"
    ];

    try {
      const reader = new FileReader();
      const fileData = await new Promise((resolve) => {
        reader.onload = (e) => resolve(e.target.result);
        reader.readAsBinaryString(file);
      });

      const workbook = XLSX.read(fileData, { type: 'binary', raw: true, cellDates: true });
      const inputSheet = workbook.Sheets[workbook.SheetNames[0]];

      // Log headers for debugging
      const headerRow = XLSX.utils.sheet_to_json(inputSheet, { header: 1 })[0];
      const inputHeaderMap = {};
      headerRow.forEach((header, index) => {
        if (header) inputHeaderMap[header.trim()] = index;
      });

      // Check if Invoice: Created Date exists
      if (!inputHeaderMap["Invoice: Created Date"]) {
        logDiv.textContent += '❌ Error: "Invoice: Created Date" column not found in input file.\n';
        throw new Error("Invoice: Created Date column missing");
      }

      const coraStatusToOwner = {};
      const valuesSheet = workbook.Sheets['Values'];
      if (valuesSheet) {
        const valuesData = XLSX.utils.sheet_to_json(valuesSheet, { header: 1 });
        const valHeaderRow = valuesData[0];
        const valHeaderMap = {};
        valHeaderRow.forEach((header, index) => {
          if (header) valHeaderMap[header.trim()] = index;
        });
        const coraStatusCol = valHeaderMap['Cora Status'];
        const ownerCol = valHeaderMap['Owner'];
        if (coraStatusCol !== undefined && ownerCol !== undefined) {
          for (let r = 1; r < valuesData.length; r++) {
            const row = valuesData[r];
            if (!row) continue;
            const coraStatus = row[coraStatusCol]?.toString().trim();
            const owner = row[ownerCol]?.toString().trim();
            if (coraStatus && owner) coraStatusToOwner[coraStatus] = owner;
          }
        }
        valuesData.length = 0;
      }

      const outputWorkbook = XLSX.utils.book_new();
      const outputSheet = XLSX.utils.json_to_sheet([desiredHeaders], { skipHeader: true });
      XLSX.utils.book_append_sheet(outputWorkbook, outputSheet, "AllocationTracker");

      const inputData = XLSX.utils.sheet_to_json(inputSheet, { header: 1 }).slice(1);
      const totalRows = inputData.length;
      const chunkSize = 100;
      let processedRows = 0;
      let dateParseFailures = 0;

      async function processChunk(startIndex) {
        const endIndex = Math.min(startIndex + chunkSize, totalRows);
        const chunkData = [];

        for (let i = startIndex; i < endIndex; i++) {
          const inputRow = inputData[i];
          if (!inputRow) continue;
          const outputRow = {};

          desiredHeaders.forEach((header) => {
            const inputHeaderKey = header === "AP Ref #" ? "Invoice: AP Ref No" :
                                  header === "PO Number" ? "OCR PO Number" : header;

            const invoiceDate = parseDateFromCell(inputRow[inputHeaderMap["Invoice: Created Date"]]);
            const assignDate = parseDateFromCell(inputRow[inputHeaderMap["Current State Assign Date"]]);

            if (header === "Created date aging" && invoiceDate) {
              outputRow[header] = Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24));
              return;
            }
            if (header === "Created date aging AH" && invoiceDate) {
              outputRow[header] = getAgingLabel(Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24)));
              return;
            }
            if (header === "Current State assigned date" && assignDate) {
              const today = normalizeDate(new Date());
              outputRow[header] = getWorkingDays(assignDate, today);
              return;
            }
            if (header === "Current state assigned date aging AH" && assignDate) {
              const today = normalizeDate(new Date());
              outputRow[header] = getAgingLabel(getWorkingDays(assignDate, today));
              return;
            }
            if (header === "Overdue/Neardue") {
              const dueDate = parseDateFromCell(inputRow[inputHeaderMap["Invoice Due Date"]]);
              if (!dueDate) {
                outputRow[header] = "Due date not captured";
              } else {
                const today = normalizeDate(new Date());
                const cal = new Date(today);
                const day = cal.getDay();
                const daysToFriday = 5 - day < 0 ? 5 - day + 7 : 5 - day;
                cal.setDate(cal.getDate() + daysToFriday);
                const thisFriday = normalizeDate(cal);
                cal.setDate(cal.getDate() + 8);
                const nextSaturday = normalizeDate(cal);
                const normalizedDueDate = normalizeDate(dueDate);

                outputRow[header] = normalizedDueDate <= thisFriday ? "Overdue" :
                                    normalizedDueDate <= nextSaturday ? "Neardue" : "Future due";
              }
              return;
            }
            if (header === "AMT in MN") {
              const amt = inputRow[inputHeaderMap["Converted Invoice Total Amount"]];
              const value = typeof amt === 'number' ? amt : parseFloat(amt) || 0;
              outputRow[header] = Math.round((value / 1000000.0) * 10000.0) / 10000.0;
              return;
            }
            if (header === "Ownership") {
              const currentState = inputRow[inputHeaderMap["Current State"]]?.toString().trim() || "";
              outputRow[header] = coraStatusToOwner[currentState] || "";
              return;
            }
            if (header === "Status") {
              const currentState = inputRow[inputHeaderMap["Current State"]]?.toString().trim() || "";
              const commentHistory = inputRow[inputHeaderMap["Comment History"]]?.toString().trim() || "";
              const owner = coraStatusToOwner[currentState] || "";
              if (commentHistory.includes("Payment feed received")) {
                outputRow[header] = "Payment feed received but Mandatory field data missing - Need to close the workflow in CORA";
              } else if (owner.toLowerCase() !== "genpact") {
                outputRow[header] = "-";
              } else if (["Awaiting Credit Note", "Pending For Supplier Credit Note", "Pending Response From Supplier"].includes(currentState)) {
                outputRow[header] = "Awaiting credit note from the supplier";
              } else {
                outputRow[header] = "Ready for TL Validation";
              }
              return;
            }
            if (header === "Inflow Type") {
              let inflowType = "";
              const createdAging = invoiceDate ? Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24)) : null;
              const assignWorkingDays = assignDate ? getWorkingDays(assignDate, normalizeDate(new Date())) : null;
              if (createdAging !== null) {
                if (createdAging <= 1) inflowType = "Fresh";
                else if (createdAging > 1 && assignWorkingDays !== null) {
                  inflowType = assignWorkingDays <= 1 ? "Comeback Fresh" : "Comeback Backlog";
                }
              }
              outputRow[header] = inflowType;
              return;
            }

            const colIndex = inputHeaderMap[inputHeaderKey];
            outputRow[header] = colIndex !== undefined ? inputRow[colIndex] ?? null : null;

            // Debug date parsing issues
            if (header === "Invoice: Created Date" && outputRow[header]) {
              const parsedDate = parseDateFromCell(outputRow[header]);
              if (!parsedDate) {
                dateParseFailures++;
                if (dateParseFailures <= 5) {
                  logDiv.textContent += `⚠️ Failed to parse date: "${outputRow[header]}" in row ${i + 2}\n`;
                }
              }
            }
          });

          chunkData.push(outputRow);
          processedRows++;
        }

        XLSX.utils.sheet_add_json(outputSheet, chunkData, { skipHeader: true, origin: -1 });

        const percent = Math.round((processedRows / totalRows) * 100);
        progressBar.style.width = percent + "%";
        progressBar.textContent = percent + "%";

        if (processedRows % 10000 === 0 || processedRows === totalRows) {
          logDiv.textContent += `Processed ${processedRows} / ${totalRows} rows...\n`;
          if (dateParseFailures > 0) {
            logDiv.textContent += `⚠️ ${dateParseFailures} date parsing failures so far\n`;
          }
          logDiv.scrollTop = logDiv.scrollHeight;
        }

        chunkData.length = 0;

        if (endIndex < totalRows) {
          setTimeout(() => processChunk(endIndex), 10);
        } else {
          inputData.length = 0;
          await finalize();
        }
      }

      async function finalize() {
        if (dateParseFailures > 0) {
          logDiv.textContent += `⚠️ Total date parsing failures: ${dateParseFailures}\n`;
        }
        const timestamp = formatDate(new Date());
        const outputFileName = `Processed_File_${timestamp}.xlsx`;
        const wbout = XLSX.write(outputWorkbook, { bookType: 'xlsx', type: 'array', compression: true });
        const blob = new Blob([wbout], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = outputFileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        processingScene.classList.remove('active');
        successAnimation.style.display = 'block';
        setTimeout(() => {
          successAnimation.style.display = 'none';
        }, 2500);
        logDiv.textContent += `✅ Output file generated: ${outputFileName}\n`;
      }

      await processChunk(0);
    } catch (err) {
      processingScene.classList.remove('active');
      logDiv.textContent += `❌ Error: ${err.message}\n`;
    }
  }

  document.getElementById('inputFile').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
      processExcel(file);
    }
  });
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jupiter Allocation</title>
  <link href="https://fonts.googleapis.com/css?family=Material+Icons|Material+Icons+Outlined" rel="stylesheet">
  <style>
    /* Same CSS as original */
  </style>
</head>
<body>
  <header>
    <h1>Jupiter Allocation</h1>
  </header>
  <main>
    <div class="scene" id="processingScene">
      <div class="rocket">
        <img src="https://i.postimg.cc/QtdPrSsD/rocket.png" alt="Rocket">
      </div>
    </div>
    <section class="upload-section">
      <input type="file" id="inputFile" class="file-input" accept=".xlsx, .xls" />
      <label for="inputFile" class="upload-label">
        <span class="material-icons-outlined">upload_file</span> Upload Excel File
      </label>
      <div id="log" class="output-log"></div>
      <div class="progress-container">
        <div id="progressBar" class="progress-bar">0%</div>
      </div>
    </section>
    <div id="successAnimation" class="success-animation">✅ Success!</div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.mini.min.js"></script>
  <script>
  function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${year}${month}${day}_${hours}${minutes}${seconds}`;
  }

  function parseDateFromCell(value) {
    if (!value) return null;
    if (typeof value === 'number') {
      const dateParts = XLSX.SSF.parse_date_code(value);
      if (!dateParts) return null;
      return new Date(dateParts.y, dateParts.m - 1, dateParts.d, dateParts.H || 0, dateParts.M || 0, dateParts.S || 0);
    }
    if (typeof value === 'string') {
      const date = new Date(value);
      if (!isNaN(date.getTime())) return date;
    }
    return null;
  }

  function getWorkingDays(start, end) {
    let startCal = new Date(start);
    let endCal = new Date(end);
    let workDays = 0;
    while (startCal <= endCal) {
      const day = startCal.getDay();
      if (day !== 0 && day !== 6) workDays++;
      startCal.setDate(startCal.getDate() + 1);
    }
    return Math.max(workDays - 1, 0);
  }

  function getAgingLabel(days) {
    if (days <= 1) return "0 - 1 day";
    if (days <= 3) return "2 - 3 days";
    if (days <= 5) return "4 - 5 days";
    return "Above 5 days";
  }

  function normalizeDate(date) {
    const cal = new Date(date);
    cal.setHours(0, 0, 0, 0);
    return cal;
  }

  function stars() {
    let scene = document.querySelector(".scene");
    let count = 20;
    for (let i = 0; i < count; i++) {
      let star = document.createElement("i");
      let x = Math.floor(Math.random() * window.innerWidth);
      let duration = Math.random() * 1 + 0.5;
      let h = Math.random() * 100;
      star.style.left = x + "px";
      star.style.width = "1px";
      star.style.height = h + "px";
      star.style.animationDuration = duration + "s";
      scene.appendChild(star);
    }
  }

  async function processExcel(file) {
    const logDiv = document.getElementById('log');
    const successAnimation = document.getElementById('successAnimation');
    const processingScene = document.getElementById('processingScene');
    const progressContainer = document.querySelector('.progress-container');
    const progressBar = document.getElementById('progressBar');

    logDiv.textContent = 'Processing file...\n';
    processingScene.classList.add('active');
    stars();
    progressContainer.style.display = "block";
    progressBar.style.width = "0%";
    progressBar.textContent = "0%";

    const desiredHeaders = [
      "Country", "AP Ref #", "Input Source", "Current State", "Work Type",
      "Exception Reason", "Document Type", "Currency", "Invoice No", "Supplier Name",
      "Supplier Number", "PO Number", "Invoice: Created Date", "Current Owner",
      "Previous State", "Comment History", "Company Code", "Current State Assign Date", "Invoice Due Date",
      "Created date aging", "Created date aging AH", "Current State assigned date",
      "Current state assigned date aging AH", "Overdue/Neardue", "Inflow Type",
      "Total Amount", "Converted Invoice Total Amount", "AMT in MN", "Ownership", "Status"
    ];

    try {
      // Read file
      const reader = new FileReader();
      const fileData = await new Promise((resolve) => {
        reader.onload = (e) => resolve(e.target.result);
        reader.readAsBinaryString(file);
      });

      const workbook = XLSX.read(fileData, { type: 'binary' });
      const inputSheet = workbook.Sheets[workbook.SheetNames[0]];

      const headerRow = XLSX.utils.sheet_to_json(inputSheet, { header: 1 })[0];
      const inputHeaderMap = {};
      headerRow.forEach((header, index) => {
        if (header) inputHeaderMap[header.trim()] = index;
      });

      // Process Values sheet for coraStatusToOwner mapping
      const coraStatusToOwner = {};
      const valuesSheet = workbook.Sheets['Values'];
      if (valuesSheet) {
        const valuesData = XLSX.utils.sheet_to_json(valuesSheet, { header: 1 });
        const valHeaderRow = valuesData[0];
        const valHeaderMap = {};
        valHeaderRow.forEach((header, index) => {
          if (header) valHeaderMap[header.trim()] = index;
        });
        const coraStatusCol = valHeaderMap['Cora Status'];
        const ownerCol = valHeaderMap['Owner'];
        if (coraStatusCol !== undefined && ownerCol !== undefined) {
          for (let r = 1; r < valuesData.length; r++) {
            const row = valuesData[r];
            if (!row) continue;
            const coraStatus = row[coraStatusCol]?.toString().trim();
            const owner = row[ownerCol]?.toString().trim();
            if (coraStatus && owner) {
              coraStatusToOwner[coraStatus] = owner;
            }
          }
        }
      }

      // Initialize output workbook
      const outputWorkbook = XLSX.utils.book_new();
      const outputSheet = XLSX.utils.json_to_sheet([desiredHeaders], { skipHeader: true });
      XLSX.utils.book_append_sheet(outputWorkbook, outputSheet, "AllocationTracker");

      // Process input data in chunks
      const inputData = XLSX.utils.sheet_to_json(inputSheet, { header: 1 }).slice(1);
      const totalRows = inputData.length;
      const chunkSize = 500;
      let processedRows = 0;

      async function processChunk(startIndex) {
        const endIndex = Math.min(startIndex + chunkSize, totalRows);
        const chunkData = [];

        for (let i = startIndex; i < endIndex; i++) {
          const inputRow = inputData[i];
          if (!inputRow) continue;
          const outputRow = {};

          desiredHeaders.forEach((header) => {
            const inputHeaderKey = header === "AP Ref #" ? "Invoice: AP Ref No" :
                                  header === "PO Number" ? "OCR PO Number" : header;

            const invoiceDate = parseDateFromCell(inputRow[inputHeaderMap["Invoice: Created Date"]]);
            const assignDate = parseDateFromCell(inputRow[inputHeaderMap["Current State Assign Date"]]);

            if (header === "Created date aging" && invoiceDate) {
              outputRow[header] = Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24));
              return;
            }
            if (header === "Created date aging AH" && invoiceDate) {
              outputRow[header] = getAgingLabel(Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24)));
              return;
            }
            if (header === "Current State assigned date" && assignDate) {
              outputRow[header] = getWorkingDays(assignDate, new Date());
              return;
            }
            if (header === "Current state assigned date aging AH" && assignDate) {
              outputRow[header] = getAgingLabel(getWorkingDays(assignDate, new Date()));
              return;
            }
            if (header === "Overdue/Neardue") {
              const dueDate = parseDateFromCell(inputRow[inputHeaderMap["Invoice Due Date"]]);
              if (!dueDate) {
                outputRow[header] = "Due date not captured";
              } else {
                const today = normalizeDate(new Date());
                const cal = new Date(today);
                const day = cal.getDay();
                const daysToFriday = 5 - day < 0 ? 5 - day + 7 : 5 - day;
                cal.setDate(cal.getDate() + daysToFriday);
                const thisFriday = normalizeDate(cal);
                cal.setDate(cal.getDate() + 8);
                const nextSaturday = normalizeDate(cal);
                const normalizedDueDate = normalizeDate(dueDate);

                outputRow[header] = normalizedDueDate <= thisFriday ? "Overdue" :
                                    normalizedDueDate <= nextSaturday ? "Neardue" : "Future due";
              }
              return;
            }
            if (header === "AMT in MN") {
              const amt = inputRow[inputHeaderMap["Converted Invoice Total Amount"]];
              const value = typeof amt === 'number' ? amt : parseFloat(amt) || 0;
              outputRow[header] = Math.round((value / 1000000.0) * 10000.0) / 10000.0;
              return;
            }
            if (header === "Ownership") {
              const currentState = inputRow[inputHeaderMap["Current State"]]?.toString().trim() || "";
              outputRow[header] = coraStatusToOwner[currentState] || "";
              return;
            }
            if (header === "Status") {
              const currentState = inputRow[inputHeaderMap["Current State"]]?.toString().trim() || "";
              const commentHistory = inputRow[inputHeaderMap["Comment History"]]?.toString().trim() || "";
              const owner = coraStatusToOwner[currentState] || "";
              if (commentHistory.includes("Payment feed received")) {
                outputRow[header] = "Payment feed received but Mandatory field data missing - Need to close the workflow in CORA";
              } else if (owner.toLowerCase() !== "genpact") {
                outputRow[header] = "-";
              } else if (["Awaiting Credit Note", "Pending For Supplier Credit Note", "Pending Response From Supplier"].includes(currentState)) {
                outputRow[header] = "Awaiting credit note from the supplier";
              } else {
                outputRow[header] = "Ready for TL Validation";
              }
              return;
            }
            if (header === "Inflow Type") {
              let inflowType = "";
              const createdAging = invoiceDate ? Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24)) : null;
              const assignWorkingDays = assignDate ? getWorkingDays(assignDate, new Date()) : null;
              if (createdAging !== null) {
                if (createdAging <= 1) inflowType = "Fresh";
                else if (createdAging > 1 && assignWorkingDays !== null) {
                  inflowType = assignWorkingDays <= 1 ? "Comeback Fresh" : "Comeback Backlog";
                }
              }
              outputRow[header] = inflowType;
              return;
            }

            const colIndex = inputHeaderMap[inputHeaderKey];
            if (colIndex !== undefined) {
              outputRow[header] = inputRow[colIndex] ?? null;
            } else {
              outputRow[header] = null;
            }
          });

          chunkData.push(outputRow);
          processedRows++;
        }

        // Append chunk to sheet
        XLSX.utils.sheet_add_json(outputSheet, chunkData, { skipHeader: true, origin: -1 });

        // Update progress
        const percent = Math.round((processedRows / totalRows) * 100);
        progressBar.style.width = percent + "%";
        progressBar.textContent = percent + "%";

        if (processedRows % 10000 === 0 || processedRows === totalRows) {
          logDiv.textContent += `Processed ${processedRows} / ${totalRows} rows...\n`;
          logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Clear chunk data to free memory
        chunkData.length = 0;

        if (endIndex < totalRows) {
          setTimeout(() => processChunk(endIndex), 0);
        } else {
          await finalize();
        }
      }

      async function finalize() {
        // Generate downloadable file
        const timestamp = formatDate(new Date());
        const outputFileName = `Processed_File_${timestamp}.xlsx`;
        const wbout = XLSX.write(outputWorkbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([wbout], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = outputFileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        processingScene.classList.remove('active');
        successAnimation.style.display = 'block';
        setTimeout(() => {
          successAnimation.style.display = 'none';
        }, 2500);
        logDiv.textContent += `✅ Output file generated: ${outputFileName}\n`;
      }

      // Clear inputData after headers are processed
      await processChunk(0);
      inputData.length = 0; // Free memory
    } catch (err) {
      processingScene.classList.remove('active');
      logDiv.textContent += `❌ Error: ${err.message}\n`;
    }
  }

  document.getElementById('inputFile').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
      processExcel(file);
    }
  });
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Jupiter Allocation</title>
  <link href="https://fonts.googleapis.com/css?family=Material+Icons|Material+Icons+Outlined" rel="stylesheet">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background-color: #f4f4f4;
      overflow-x: hidden;
    }
    header {
      background-color: #4CAF50;
      color: white;
      padding: 1rem;
      text-align: center;
      position: relative;
      z-index: 10;
    }
    main {
      padding: 1rem;
      position: relative;
      min-height: 100vh;
      z-index: 5;
    }
    .upload-section {
      background: white;
      padding: 2rem;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      text-align: center;
      position: relative;
      z-index: 10;
      max-width: 500px;
      margin: 0 auto;
    }
    .file-input {
      display: none;
    }
    .upload-label {
      display: inline-block;
      padding: 0.5rem 1rem;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      border-radius: 4px;
      transition: transform 0.3s ease, background-color 0.3s ease;
    }
    .upload-label:hover {
      transform: scale(1.1);
      background-color: #45a049;
    }
    .output-log {
      margin-top: 1rem;
      white-space: pre-wrap;
      background: #eee;
      padding: 1rem;
      border-radius: 4px;
      font-size: 0.9rem;
      position: relative;
      z-index: 10;
    }
    /* Rocket and Stars Animation */
    .scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #151515;
      z-index: 2;
      display: none;
    }
    .scene.active {
      display: flex;
    }
    .rocket {
      position: relative;
      animation: animate 0.2s ease infinite;
    }
    .rocket::after {
      content: "";
      position: absolute;
      bottom: -200px;
      left: 50%;
      transform: translateX(-50%);
      width: 10px;
      height: 200px;
      background: linear-gradient(#00d0ff, transparent);
    }
    .scene i {
      position: absolute;
      top: -200px;
      background-color: rgba(255, 255, 255, 0.5);
      animation: animateStars linear infinite;
    }
    @keyframes animate {
      0% { transform: translateY(2px); }
      100% { transform: translateY(-2px); }
    }
    @keyframes animateStars {
      0% { transform: translateY(0); }
      100% { transform: translateY(200vh); }
    }
    /* Success Animation */
    .success-animation {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 3rem;
      color: #4CAF50;
      text-align: center;
      animation: popIn 0.5s ease-out, fadeOut 2s 1s forwards;
      z-index: 1000;
      display: none;
    }
    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @keyframes fadeOut {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Jupiter Allocation</h1>
  </header>
  <main>
    <div class="scene" id="processingScene">
      <div class="rocket">
        <img src="https://i.postimg.cc/QtdPrSsD/rocket.png" alt="Rocket">
      </div>
    </div>
    <section class="upload-section">
      <input type="file" id="inputFile" class="file-input" accept=".xlsx, .xls" />
      <label for="inputFile" class="upload-label">
        <span class="material-icons-outlined">upload_file</span> Upload Excel File
      </label>
      <div id="log" class="output-log"></div>
    </section>
    <div id="successAnimation" class="success-animation">âœ… Success!</div>
  </main>

  <!-- âš¡ Using the lightweight SheetJS build -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.mini.min.js"></script>

  <script>
  function formatDate(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${year}${month}${day}_${hours}${minutes}${seconds}`;
  }

  function parseDateFromCell(value) {
    if (!value) return null;
    if (typeof value === 'number') {
      const dateParts = XLSX.SSF.parse_date_code(value);
      if (!dateParts) return null;
      return new Date(
        dateParts.y,
        dateParts.m - 1,
        dateParts.d,
        dateParts.H || 0,
        dateParts.M || 0,
        dateParts.S || 0
      );
    }
    if (typeof value === 'string') {
      const date = new Date(value);
      if (!isNaN(date.getTime())) return date;
    }
    return null;
  }

  function getWorkingDays(start, end) {
    let startCal = new Date(start);
    let endCal = new Date(end);
    let workDays = 0;
    while (startCal <= endCal) {
      const day = startCal.getDay();
      if (day !== 0 && day !== 6) workDays++;
      startCal.setDate(startCal.getDate() + 1);
    }
    return Math.max(workDays - 1, 0);
  }

  function getAgingLabel(days) {
    if (days <= 1) return "0 - 1 day";
    if (days <= 3) return "2 - 3 days";
    if (days <= 5) return "4 - 5 days";
    return "Above 5 days";
  }

  function normalizeDate(date) {
    const cal = new Date(date);
    cal.setHours(0, 0, 0, 0);
    return cal;
  }

  function stars() {
    let scene = document.querySelector(".scene");
    let count = 20;
    for (let i = 0; i <= count; i++) {
      let star = document.createElement("i");
      let x = Math.floor(Math.random() * window.innerWidth);
      let duration = Math.random() * 1 + 0.5;
      let h = Math.random() * 100;
      star.style.left = x + "px";
      star.style.width = 1 + "px";
      star.style.height = h + "px";
      star.style.animationDuration = duration + "s";
      scene.appendChild(star);
    }
  }

  async function processExcel(file) {
    const logDiv = document.getElementById("log");
    const successAnimation = document.getElementById("successAnimation");
    const processingScene = document.getElementById("processingScene");
    logDiv.textContent = "Processing file...\n";
    processingScene.classList.add("active");
    stars();

    const desiredHeaders = [
      "Country", "AP Ref #", "Input Source", "Current State", "Work Type",
      "Exception Reason", "Document Type", "Currency", "Invoice No", "Supplier Name",
      "Supplier Number", "PO Number", "Invoice: Created Date", "Current Owner",
      "Previous State", "Comment History", "Company Code", "Current State Assign Date", "Invoice Due Date",
      "Created date aging", "Created date aging AH", "Current State assigned date",
      "Current state assigned date aging AH", "Overdue/Neardue", "Inflow Type",
      "Total Amount", "Converted Invoice Total Amount", "AMT in MN", "Ownership", "Status"
    ];

    try {
      // Read file as ArrayBuffer
      const reader = new FileReader();
      const fileData = await new Promise((resolve) => {
        reader.onload = (e) => resolve(new Uint8Array(e.target.result));
        reader.readAsArrayBuffer(file);
      });

      const workbook = XLSX.read(fileData, { type: "array" });
      const inputSheet = workbook.Sheets[workbook.SheetNames[0]];

      // Build input header map (first row)
      const range = XLSX.utils.decode_range(inputSheet["!ref"]);
      const inputHeaderMap = {};
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cell = inputSheet[XLSX.utils.encode_cell({ r: range.s.r, c: C })];
        if (cell && cell.v) {
          inputHeaderMap[cell.v.toString().trim()] = C;
        }
      }

      // Load mapping sheet "Values"
      const valuesSheet = workbook.Sheets["Values"];
      const coraStatusToOwner = {};
      if (valuesSheet) {
        const valuesData = XLSX.utils.sheet_to_json(valuesSheet, { header: 1 });
        const valHeaderRow = valuesData[0];
        const valHeaderMap = {};
        valHeaderRow.forEach((header, index) => {
          valHeaderMap[header.trim()] = index;
        });
        const coraStatusCol = valHeaderMap["Cora Status"];
        const ownerCol = valHeaderMap["Owner"];
        for (let r = 1; r < valuesData.length; r++) {
          const row = valuesData[r];
          if (!row) continue;
          const coraStatus = row[coraStatusCol]?.toString().trim();
          const owner = row[ownerCol]?.toString().trim();
          if (coraStatus && owner) coraStatusToOwner[coraStatus] = owner;
        }
      }

      // Prepare output
      const outputSheetData = [desiredHeaders];

      // ðŸ”¹ Process rows one-by-one instead of full JSON
      for (let R = range.s.r + 1; R <= range.e.r; ++R) {
        const rowValues = {};
        for (const key in inputHeaderMap) {
          const C = inputHeaderMap[key];
          const cell = inputSheet[XLSX.utils.encode_cell({ r: R, c: C })];
          rowValues[key] = cell ? cell.v : null;
        }

        const outputRow = new Array(desiredHeaders.length).fill(null);

        desiredHeaders.forEach((header, j) => {
          const inputHeaderKey =
            header === "AP Ref #" ? "Invoice: AP Ref No" :
            header === "PO Number" ? "OCR PO Number" : header;

          const invoiceDate = parseDateFromCell(rowValues["Invoice: Created Date"]);
          const assignDate = parseDateFromCell(rowValues["Current State Assign Date"]);

          if (header === "Created date aging" && invoiceDate) {
            outputRow[j] = Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24));
            return;
          }
          if (header === "Created date aging AH" && invoiceDate) {
            const diffDays = Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24));
            outputRow[j] = getAgingLabel(diffDays);
            return;
          }
          if (header === "Current State assigned date" && assignDate) {
            outputRow[j] = getWorkingDays(assignDate, new Date());
            return;
          }
          if (header === "Current state assigned date aging AH" && assignDate) {
            const workingDays = getWorkingDays(assignDate, new Date());
            outputRow[j] = getAgingLabel(workingDays);
            return;
          }
          if (header === "Overdue/Neardue") {
            const dueDate = parseDateFromCell(rowValues["Invoice Due Date"]);
            if (!dueDate) {
              outputRow[j] = "Due date not captured";
            } else {
              const today = normalizeDate(new Date());
              const cal = new Date(today);
              const day = cal.getDay();
              const daysToFriday = 5 - day < 0 ? 5 - day + 7 : 5 - day;
              cal.setDate(cal.getDate() + daysToFriday);
              const thisFriday = normalizeDate(cal);
              cal.setDate(cal.getDate() + 8);
              const nextSaturday = normalizeDate(cal);
              const normalizedDueDate = normalizeDate(dueDate);
              if (normalizedDueDate <= thisFriday) outputRow[j] = "Overdue";
              else if (normalizedDueDate <= nextSaturday) outputRow[j] = "Neardue";
              else outputRow[j] = "Future due";
            }
            return;
          }
          if (header === "AMT in MN") {
            const amt = rowValues["Converted Invoice Total Amount"];
            const value = typeof amt === "number" ? amt : parseFloat(amt) || 0;
            outputRow[j] = Math.round((value / 1000000.0) * 10000.0) / 10000.0;
            return;
          }
          if (header === "Ownership") {
            const currentState = rowValues["Current State"]?.toString().trim() || "";
            outputRow[j] = coraStatusToOwner[currentState] || "";
            return;
          }
          if (header === "Status") {
            const currentState = rowValues["Current State"]?.toString().trim() || "";
            const commentHistory = rowValues["Comment History"]?.toString().trim() || "";
            const owner = coraStatusToOwner[currentState] || "";

            if (commentHistory.includes("Payment feed received")) {
              outputRow[j] =
                "Payment feed received but Mandatory field data missing - Need to close the workflow in CORA";
            } else if (owner.toLowerCase() !== "genpact") {
              outputRow[j] = "-";
            } else if (
              ["Awaiting Credit Note", "Pending For Supplier Credit Note", "Pending Response From Supplier"].includes(currentState)
            ) {
              outputRow[j] = "Awaiting credit note from the supplier";
            } else {
              outputRow[j] = "Ready for TL Validation";
            }
            return;
          }
          if (header === "Inflow Type") {
            let inflowType = "";
            const createdAging = invoiceDate ? Math.floor((new Date() - invoiceDate) / (1000 * 60 * 60 * 24)) : null;
            const assignWorkingDays = assignDate ? getWorkingDays(assignDate, new Date()) : null;
            if (createdAging !== null) {
              if (createdAging <= 1) inflowType = "Fresh";
              else if (createdAging > 1 && assignWorkingDays !== null) {
                inflowType = assignWorkingDays <= 1 ? "Comeback Fresh" : "Comeback Backlog";
              }
            }
            outputRow[j] = inflowType;
            return;
          }

          // Default copy from input
          const colIndex = inputHeaderMap[inputHeaderKey];
          if (colIndex !== undefined) {
            outputRow[j] = rowValues[inputHeaderKey] ?? null;
          }
        });

        outputSheetData.push(outputRow);

        // ðŸ”¹ Flush log every 1000 rows so UI doesnâ€™t freeze
        if ((R - range.s.r) % 1000 === 0) {
          logDiv.textContent = `Processed ${R - range.s.r} rows...\n`;
          await new Promise((res) => setTimeout(res, 0));
        }
      }

      // Write result
      const outputWorkbook = XLSX.utils.book_new();
      const outputSheet = XLSX.utils.aoa_to_sheet(outputSheetData);
      XLSX.utils.book_append_sheet(outputWorkbook, outputSheet, "AllocationTracker");

      const timestamp = formatDate(new Date());
      const outputFileName = `Processed_File_${timestamp}.xlsx`;
      const wbout = XLSX.write(outputWorkbook, { bookType: "xlsx", type: "array" });
      const blob = new Blob([wbout], { type: "application/octet-stream" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = outputFileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      processingScene.classList.remove("active");
      successAnimation.style.display = "block";
      setTimeout(() => { successAnimation.style.display = "none"; }, 2500);
      logDiv.textContent += `âœ… Output file generated: ${outputFileName}\n`;
    } catch (err) {
      processingScene.classList.remove("active");
      logDiv.textContent += `âŒ Error: ${err.message}\n`;
    }
  }

  document.getElementById("inputFile").addEventListener("change", (event) => {
    const file = event.target.files[0];
    if (file) processExcel(file);
  });
</script>

</body>
</html>
